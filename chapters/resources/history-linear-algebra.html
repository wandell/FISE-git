<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>history-linear-algebra</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="history-linear-algebra_files/libs/clipboard/clipboard.min.js"></script>
<script src="history-linear-algebra_files/libs/quarto-html/quarto.js"></script>
<script src="history-linear-algebra_files/libs/quarto-html/popper.min.js"></script>
<script src="history-linear-algebra_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="history-linear-algebra_files/libs/quarto-html/anchor.min.js"></script>
<link href="history-linear-algebra_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="history-linear-algebra_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="history-linear-algebra_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="history-linear-algebra_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="history-linear-algebra_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="a-conversation-on-teaching-optics-and-the-history-of-linear-algebra" class="level1">
<h1><strong>A Conversation on Teaching Optics and the History of Linear Algebra</strong></h1>
<p>This document captures a discussion about pedagogical approaches to linear optics and the historical development of key concepts in linear algebra that underpin the field.</p>
<section id="rethinking-the-teaching-order-eigenfunctions-before-harmonics" class="level3">
<h3 class="anchored" data-anchor-id="rethinking-the-teaching-order-eigenfunctions-before-harmonics"><strong>1. Rethinking the Teaching Order: Eigenfunctions Before Harmonics</strong></h3>
<p><strong>User:</strong> I am teaching students about linear optics. I am considering the order of presentation. Normally, I would start with the idea of a linear system. Then I would go to harmonics as eigenfunctions of shift invariant linear systems.</p>
<p>But I am reconsidering. I am thinking about starting with linear systems, emphasizing that for discrete calculations a linear system is represented by a matrix. Then explaining that the eigenfunctions of the matrix are an orthonormal basis for the inputs to the system. And then saying that when the system is shift-invariant, and optics is generally shift-invariant (isoplanatic) over small regions, the harmonics are almost eigenfunctions. If we represent them using complex exponentials, they are eigenfunctions.</p>
<p>What do you think about the 2nd approach, where eigenfunctions come before harmonics?</p>
<p>I think your second approach is excellent and likely more insightful for students.</p>
<p>It frames the Fourier basis not as a convenient mathematical trick, but as the <strong>fundamental, natural basis</strong> for describing the behavior of shift-invariant systems. This ‚Äúwhy‚Äù is often missing from the traditional presentation.</p>
<section id="evaluation-of-your-proposed-approach" class="level4">
<h4 class="anchored" data-anchor-id="evaluation-of-your-proposed-approach"><strong>Evaluation of Your Proposed Approach</strong></h4>
<p><strong>Strengths üëç</strong></p>
<ol type="1">
<li><strong>Strong Motivation:</strong> It directly answers the question, ‚ÄúWhy do we use sine waves and complex exponentials (harmonics) to analyze optical systems?‚Äù The answer is because they are the <strong>eigenfunctions</strong>‚Äîthe special functions that don‚Äôt change their form when passing through the system. This provides a much deeper motivation than simply stating that they are a convenient orthogonal basis.<br>
</li>
<li><strong>Concrete to Abstract:</strong> Starting with matrices is a powerful pedagogical tool. Students in physics and engineering typically have a more concrete understanding of linear algebra (vectors and matrices) than functional analysis. Showing that eigenvectors form a special basis for a matrix operator provides a solid foundation before generalizing from discrete vectors (v) to continuous functions (f(x)).<br>
</li>
<li><strong>Unifies Concepts:</strong> This approach beautifully connects two major topics: linear algebra and Fourier analysis. Students can see that the Fourier transform is not an isolated tool but a specific application of eigen-decomposition for the special case of shift-invariant operators.</li>
</ol>
</section>
<section id="a-suggested-refinement-for-maximum-impact" class="level4">
<h4 class="anchored" data-anchor-id="a-suggested-refinement-for-maximum-impact"><strong>A Suggested Refinement for Maximum Impact</strong></h4>
<p>To make the connection between matrices and shift-invariance even more explicit, you can introduce the concept of a <strong>circulant matrix</strong>. This provides the perfect bridge from the discrete to the continuous.</p>
<p><strong>Proposed Teaching Flow:</strong></p>
<ol type="1">
<li><strong>Linear Systems and Matrices:</strong> Start as you planned. A linear system is an operator L such that L[x]=y. In the discrete, finite case, this is a matrix multiplication: Ax=y.<br>
</li>
<li><strong>Eigenvectors as a Natural Basis:</strong> Explain that for any matrix A, the eigenvectors ei‚Äã are the ‚Äúspecial‚Äù inputs. When an eigenvector is the input, the output is just a scaled version of the input: Aei‚Äã=Œªi‚Äãei‚Äã.<br>
</li>
<li><strong>Introduce Shift-Invariance (Discrete):</strong> Now, consider a specific type of linear system: a discrete, shift-invariant system (or more accurately, a system with periodic boundary conditions). The operation is a <strong>circular convolution</strong>. Show students the matrix C that represents this operation. They will see that each row is a shifted version of the row above it. This is a <strong>circulant matrix</strong>.<br>
</li>
<li><strong>The ‚ÄúAha!‚Äù Moment üí°:</strong> State the powerful theorem: <strong>The eigenvectors of <em>any</em> circulant matrix are the basis vectors of the Discrete Fourier Transform (DFT)</strong>. These are the discrete complex exponentials. This is not a coincidence; it‚Äôs a fundamental property.<br>
</li>
<li><strong>Generalize to Continuous Optics:</strong> Now, make the leap from discrete to continuous. A discrete input vector becomes a continuous function, a circulant matrix becomes a convolution integral, and the DFT basis vectors become the continuous complex exponentials, which are the eigenfunctions of any continuous, shift-invariant system.</li>
</ol>
</section>
</section>
<section id="minor-question-circulant-vs.-toeplitz-matrices" class="level3">
<h3 class="anchored" data-anchor-id="minor-question-circulant-vs.-toeplitz-matrices"><strong>2. Minor Question: Circulant vs.&nbsp;Toeplitz Matrices</strong></h3>
<p><strong>User:</strong> Minor question: Is circulant matrix widely used, or is Toeplitz more common?</p>
<p>Excellent question. While they are related, they serve different roles.</p>
<p><strong>Toeplitz matrices are the more general and fundamental concept, but circulant matrices are more widely used in computational algorithms.</strong></p>
<section id="toeplitz-matrix-the-general-form" class="level4">
<h4 class="anchored" data-anchor-id="toeplitz-matrix-the-general-form"><strong>Toeplitz Matrix: The General Form</strong></h4>
<p>A <strong>Toeplitz matrix</strong> has constant values along each of its diagonals. It is the exact matrix representation of a <strong>linear convolution</strong> operation, which is fundamental to linear, time-invariant (LTI) systems.</p>
</section>
<section id="circulant-matrix-the-computational-powerhouse" class="level4">
<h4 class="anchored" data-anchor-id="circulant-matrix-the-computational-powerhouse"><strong>Circulant Matrix: The Computational Powerhouse</strong></h4>
<p>A <strong>circulant matrix</strong> is a special type of Toeplitz matrix where each row is a cyclic shift of the row above it. It represents <strong>circular convolution</strong>. Its ‚Äúkiller feature‚Äù is that it is diagonalized by the Discrete Fourier Transform (DFT) matrix, which allows for incredibly fast computations (O(NlogN)) using the Fast Fourier Transform (FFT).</p>
<p><strong>The Bottom Line:</strong></p>
<ol type="1">
<li><strong>Generality:</strong> Toeplitz is the more general structure.<br>
</li>
<li><strong>Computation:</strong> Circulant matrices are the key to fast computation. In fact, the standard way to perform a fast linear convolution (a Toeplitz operation) is to pad the input signals and use circular convolution (a circulant operation) via the FFT.</li>
</ol>
</section>
</section>
<section id="historical-context-who-linked-matrices-to-linear-systems" class="level3">
<h3 class="anchored" data-anchor-id="historical-context-who-linked-matrices-to-linear-systems"><strong>3. Historical Context: Who Linked Matrices to Linear Systems?</strong></h3>
<p><strong>User:</strong> Separately, historically who would you associate with the notion that a discrete linear system can be represented by a matrix? I have Grassmann for the initial framing in terms of linear algebra of multidimensional spaces. But I don‚Äôt know who really got the relationship between matrices and linear systems firmly grounded.</p>
<p>That‚Äôs an excellent historical question. You‚Äôve correctly identified <strong>Hermann Grassmann</strong> as a pivotal, yet often overlooked, figure. However, the person most credited with firmly grounding the relationship between <em>matrices as an algebraic object</em> and <em>systems of linear transformations</em> is the English mathematician <strong>Arthur Cayley</strong>.</p>
<section id="the-key-19th-century-figures" class="level4">
<h4 class="anchored" data-anchor-id="the-key-19th-century-figures"><strong>The Key 19th-Century Figures</strong></h4>
<ol type="1">
<li>Hermann Grassmann (1844): The Visionary Abstract Thinker<br>
In his work, Die Lineale Ausdehnungslehre, he developed the first axiomatic theory of what we now call a vector space and conceived of linear transformations in this general, abstract sense. However, his work was highly philosophical and largely ignored for decades.<br>
</li>
<li>James Joseph Sylvester (1850): The Namer<br>
A close collaborator of Cayley, J.J. Sylvester was the first to use the term ‚Äúmatrix‚Äù (from the Latin for ‚Äúwomb‚Äù), seeing it as a generator of determinants.<br>
</li>
<li>Arthur Cayley (1855, 1858): The Father of Matrix Algebra<br>
Cayley is the figure you‚Äôre looking for. In his Memoir on the Theory of Matrices (1858), he:
<ul>
<li><strong>Defined Matrix Operations:</strong> Systematically defined matrix addition, scalar multiplication, and matrix multiplication.<br>
</li>
<li><strong>Connected Matrices to Transformations:</strong> He explicitly showed that the composition of two linear transformations corresponds to the product of their representative matrices.<br>
</li>
<li><strong>Developed an Algebra of Matrices:</strong> He introduced the identity matrix, the inverse matrix, and explored their properties, including the famous Cayley-Hamilton theorem.</li>
</ul></li>
</ol>
<p><strong>In Summary:</strong> While Grassmann laid the abstract foundation, <strong>it was Arthur Cayley who firmly grounded the idea that a discrete linear system (a linear transformation) is represented by a matrix, and that the algebra of these matrices governs the system‚Äôs behavior.</strong></p>
<p><strong>User:</strong> Was Cayley well aware of Grassmann‚Äôs work and building on it?</p>
<p>The historical consensus is that <strong>no, Cayley was almost certainly not aware of Grassmann‚Äôs work and did not build upon it.</strong> They arrived at similar conceptual territories via two very different, parallel paths.</p>
<ul>
<li><strong>Grassmann‚Äôs Path (Axiomatic and Philosophical):</strong> Grassmann was attempting to build a completely new, axiomatic foundation for geometry in <em>n</em>-dimensions. His work was abstract, dense, and published far from the main mathematical centers, so it remained obscure for decades.<br>
</li>
<li><strong>Cayley‚Äôs Path (Algebraic and Concrete):</strong> Cayley was motivated by the theory of invariants and the geometry of linear transformations. He needed an efficient notation and algebra for describing how geometric objects change under transformations. His approach was to take the concrete array of numbers‚Äîthe matrix‚Äîand build an operational algebra around it.</li>
</ul>
<p>The two streams of thought were eventually unified by a later generation of mathematicians like <strong>William Kingdon Clifford</strong> and <strong>Giuseppe Peano</strong>, who recognized the power of combining Grassmann‚Äôs abstract structures with Cayley‚Äôs computational engine.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>