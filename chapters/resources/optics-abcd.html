<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>optics-abcd</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="multi-element-lens-calculations" class="level1">
<h1>Multi-element lens calculations</h1>
<p>https://chatgpt.com/share/66fc291d-6780-8002-b144-e42045f37ea2</p>
<p>Yes, you can compute the effective focal length of a multi-element lens system if you know the refractive index, curvatures, and positions of each lens element. To do this, you would use the matrix method (or ray transfer matrix analysis), which is a standard approach in geometric optics for analyzing systems with multiple optical elements. Here’s a general outline of the process:</p>
<p>Steps: Lensmaker’s Equation for Individual Lenses: For each individual spherical lens, you can use the lensmaker’s equation to find the focal length ( f ) of the lens: [ = (n - 1) ( - )] where: ( n ) is the refractive index of the lens material, ( R_1 ) and ( R_2 ) are the radii of curvature of the lens surfaces (positive for convex, negative for concave). Ray Transfer Matrices: For each optical element, you can describe its effect on a ray of light using a matrix. The main matrices used are: Refraction through a lens: [ ] where ( f ) is the focal length of the lens. Propagation through free space (distance ( d )): [ ] Multiplying Matrices: Multiply the matrices for each lens and spacing in sequence from the first element to the last. This will give you an overall system matrix ( M ) of the form: [ M = ] where ( A ), ( B ), ( C ), and ( D ) are the elements of the resulting matrix after multiplication. Effective Focal Length: The effective focal length ( f_{} ) of the system can be found from the matrix ( M ) using the relation: [ f_{} = -] where ( C ) is the element in the bottom-left of the system matrix ( M ). Example:</p>
<p>For a system of two lenses separated by a distance ( d ):</p>
<p>Calculate the individual focal lengths ( f_1 ) and ( f_2 ) using the lensmaker’s equation. Multiply the matrices for the first lens, the propagation through the distance ( d ), and the second lens. Extract ( C ) from the resulting matrix and compute the effective focal length.</p>
<p>This method is scalable to any number of lenses and is commonly used in optical system design.</p>
<p>Would you like help with a specific example or more details about this process?</p>
<p>The ray transfer matrix (also known as the ABCD matrix) is a formalism used in geometrical optics to describe how light rays propagate through optical systems, including lenses, mirrors, and free space. It provides a way to predict how a light ray’s position and angle change as it passes through an optical element.</p>
<p>Ray Parameters</p>
<p>The ray transfer matrix acts on the ray’s state, which is typically described by two parameters:</p>
<p>Position ( y ): The height (or transverse displacement) of the ray relative to the optical axis. Angle ( ): The angle that the ray makes with the optical axis.</p>
<p>In matrix notation, the ray’s state is expressed as a column vector: [ = ]</p>
<p>This vector contains the position ( y ) and the angle ( ) of the ray at a particular point in the optical system.</p>
<p>Ray Transfer Matrix</p>
The ray transfer matrix ( M ), also called the system matrix, describes how the position and angle of the ray change as it passes through an optical element. For an optical system or element, the transfer matrix is written as: [ M = ] This matrix transforms the ray parameters from one side of the optical element (or system) to the other. The relation between the ray parameters before and after the system is: [
<span class="math display">\[\begin{pmatrix}
y_2 \
\theta_2

\end{pmatrix}\]</span>
<p>\end{pmatrix}</p>
<span class="math display">\[\begin{pmatrix}
A &amp; B \
C &amp; D
\end{pmatrix}\]</span>
\end{pmatrix}
<span class="math display">\[\begin{pmatrix}
y_1 \
\theta_1
\end{pmatrix}\]</span>
<p>\end{pmatrix} ] where:</p>
<p>( y_1 ) and ( _1 ) are the initial position and angle of the ray (before the element), ( y_2 ) and ( _2 ) are the position and angle after the element.</p>
<p>The matrix elements ( A ), ( B ), ( C ), and ( D ) depend on the type of optical element (lens, free space, mirror, etc.).</p>
<p>Interpretation of Matrix Elements ( A ): Describes how the initial position ( y_1 ) influences the final position ( y_2 ). ( B ): Describes how the initial angle ( _1 ) influences the final position ( y_2 ) (this is related to the system’s “focusing” effect). ( C ): Describes how the initial position ( y_1 ) influences the final angle ( _2 ) (related to the system’s “bending” of rays). ( D ): Describes how the initial angle ( _1 ) influences the final angle ( _2 ). Example of Ray Propagation through Free Space</p>
<p>In free space, over a distance ( d ), the ray transfer matrix is: [ M = ] This matrix implies that:</p>
<p>The ray’s position changes according to ( y_2 = y_1 + d_1 ), meaning the ray moves along a straight line depending on its initial angle. The ray’s angle remains unchanged: ( _2 = _1 ). Example of Ray Propagation through a Thin Lens</p>
<p>For a thin lens with focal length ( f ), the ray transfer matrix is: [ M = ] This matrix implies that:</p>
<p>The ray’s angle changes according to ( _2 = _1 - ), which corresponds to the focusing effect of the lens. The position of the ray is unchanged: ( y_2 = y_1 ). Ray Propagation through a System</p>
<p>To predict the behavior of a ray through a multi-element optical system, you multiply the matrices of each individual element. The overall matrix for the system is the product of the matrices of the elements in the order the ray encounters them. This final matrix can then be used to find the ray’s final position and angle after passing through the entire system.</p>
<p>In summary, the ray transfer matrix predicts how the position and angle of a ray evolve as it propagates through an optical element or system. By multiplying the ray’s initial state by the transfer matrix, you can calculate its state after traversing the optical system.</p>
<p>Yes, you are correct! When using the ray transfer matrix to calculate the propagation of a ray through a lens, you generally assume that:</p>
<p>The ray enters the lens from the left side. The radius of curvature of the lens surface on the left-hand side (where the ray first encounters the lens) is ( R_1 ). The radius of curvature of the lens surface on the right-hand side (where the ray exits the lens) is ( R_2 ).</p>
<p>In terms of ray transfer matrices, the process looks like this:</p>
<p>Ray Transfer Matrix Setup</p>
<p>For a single spherical lens, the complete ray transfer matrix involves two primary types of matrices:</p>
<p>Refraction at the surfaces of the lens (at ( R_1 ) and ( R_2 )), Propagation through the thickness of the lens (if it has a non-negligible thickness).</p>
<p>You would calculate the overall matrix by multiplying these matrices in sequence, taking into account:</p>
<p>Free-space propagation before and after the lens (if relevant), The two refractions at the curved surfaces ( R_1 ) and ( R_2 ), Propagation through the lens medium (if the lens has some thickness ( t )). Standard Case (Thin Lens Approximation)</p>
<p>In the thin lens approximation (where the thickness of the lens is negligible), you don’t need to consider propagation through the lens. The ray transfer matrix for a thin lens is given by: [ M_{} = ] where ( f ) is the focal length of the lens, which you can calculate using the lensmaker’s equation: [ = (n - 1) ( - )] Here:</p>
<p>( n ) is the refractive index of the lens material, ( R_1 ) is the radius of curvature of the surface the ray first encounters (left-hand side), ( R_2 ) is the radius of curvature of the surface the ray exits through (right-hand side). Full Calculation for a Thick Lens</p>
<p>If the lens is thick, meaning it has a non-negligible thickness ( t ), the full ray transfer matrix would consist of three steps:</p>
<p>Refraction at the first surface (with radius ( R_1 )): [ M_{} = ] where: ( n_1 ) is the refractive index of the medium on the left (e.g., air), ( n_2 ) is the refractive index of the lens material, ( R_1 ) is the radius of curvature of the first surface (positive for convex, negative for concave). Propagation through the lens material (distance ( t )): [ M_{} = ] where ( t ) is the thickness of the lens and ( n_2 ) is the refractive index of the lens. Refraction at the second surface (with radius ( R_2 )): [ M_{} = ] where: ( n_1 ) is again the refractive index of the medium outside the lens (e.g., air), ( n_2 ) is the refractive index of the lens material, ( R_2 ) is the radius of curvature of the second surface (positive for convex, negative for concave). Matrix Product for Thick Lens</p>
<p>To calculate the total effect of the lens on the ray, you multiply these matrices in sequence: [ M_{} = M_{} M_{} M_{}]</p>
<p>The result of this matrix product gives you the overall transformation of the ray’s position and angle as it enters and exits the lens system.</p>
<p>Applying the Matrix to the Ray</p>
Once you have the total ray transfer matrix ( M_{} ), you can apply it to the initial ray vector ( _1 =
<span class="math display">\[\begin{pmatrix} y_1 \ \theta_1 \end{pmatrix}\]</span>
<p>), where ( y_1 ) is the initial position of the ray and ( _1 ) is its angle of incidence with respect to the optical axis.</p>
The output ray vector ( 2 =
<span class="math display">\[\begin{pmatrix} y_2 \ \theta_2 \end{pmatrix}\]</span>
<p>) is given by: [ _2 = M{} _1] where ( y_2 ) is the position of the ray after exiting the lens and ( _2 ) is its new angle.</p>
Summary The ray enters the lens on the left, and the matrix describes how its position and angle are transformed. ( R_1 ) is the radius of curvature on the left side of the lens (where the ray enters), and ( R_2 ) is on the right (where the ray exits). The matrix product results in a new ray vector ( _2 =
<span class="math display">\[\begin{pmatrix} y_2 \ \theta_2 \end{pmatrix}\]</span>
<p>), which gives the ray’s position and angle after it exits the lens.</p>
<p>This approach is widely used in designing and analyzing optical systems, particularly in lens systems with multiple elements!</p>
<p>Optics designers use multi-element lenses instead of simple thin lenses for several important reasons. While a single thin lens can perform basic focusing and image formation, multi-element lenses are necessary to address more complex optical requirements and improve image quality in advanced applications. Here are some of the main reasons:</p>
<ol type="1">
<li>Correction of Aberrations Spherical Aberration: In a single lens, spherical surfaces cause spherical aberration, where rays passing through the edge of the lens focus at a different point than rays passing near the center. Multi-element lenses can be designed to correct this by combining lenses of different shapes and refractive indices. Chromatic Aberration: A single lens causes chromatic aberration because different wavelengths of light are refracted by different amounts (dispersion), leading to color fringing around images. Multi-element lenses, such as achromatic doublets (two lenses made of different materials), can reduce or eliminate chromatic aberration by compensating for the wavelength-dependent behavior of light. Coma and Astigmatism: Coma (where off-axis points appear distorted or smeared) and astigmatism (where vertical and horizontal lines focus at different distances) are other common aberrations that multi-element lens systems help to correct.</li>
<li>Improved Image Quality Across a Wide Field of View A single thin lens may perform well on-axis (directly in front of the lens), but off-axis performance tends to degrade, leading to issues like distortion, vignetting, and aberrations. Multi-element lenses can be optimized to deliver consistent image quality across a wider field of view, making them essential for applications like wide-angle photography and cinematography.</li>
<li>Faster Apertures Designers can achieve larger apertures (lower f-numbers) with multi-element lenses while maintaining acceptable image quality. A simple thin lens with a large aperture will introduce significant aberrations, but with multiple lens elements, optical performance can be preserved even at wide apertures, enabling more light to enter the system and allowing for better low-light performance and shallower depth of field.</li>
<li>Control of Distortion Distortion (such as barrel or pincushion distortion) occurs when straight lines in the scene appear curved in the image. A simple lens often introduces some distortion, especially for wide-angle fields of view. Multi-element lenses, such as zoom lenses or complex prime lenses, are specifically designed to control and minimize distortion, resulting in more accurate image reproduction.</li>
<li>Zoom Capabilities Simple lenses offer a fixed focal length, but many optical systems, such as camera zoom lenses, require variable focal lengths. Multi-element zoom lenses allow designers to change the focal length smoothly while maintaining focus. This flexibility is crucial for many applications, such as photography, videography, and surveillance.</li>
<li>Compact Design with High Performance High-performance optical systems, such as those used in smartphones, microscopes, and high-quality cameras, require compact lenses with excellent image quality. A multi-element design allows designers to achieve a balance between compactness and optical correction. The use of multiple elements can help to shorten the overall length of the lens system while still providing the required focal length and performance.</li>
<li>Wide Wavelength and Spectral Range In specialized applications (e.g., infrared imaging or ultraviolet optics), different lens materials may be required to handle different parts of the spectrum efficiently. A multi-element lens can use various materials (like glass, plastic, or crystalline materials) to optimize performance across a wide spectral range.</li>
<li>Mechanical and Manufacturing Constraints It is often easier and more cost-effective to manufacture and assemble several simpler lens elements than to attempt to create a single lens element with highly complex shapes or specialized properties. Additionally, multi-element lenses allow designers to use standard lens shapes and coatings while achieving the desired optical properties, simplifying the design and production process.</li>
<li>Reduction of Ghosting and Flare Light reflecting internally between the surfaces of lens elements can create ghost images or flare, reducing image contrast. By using multi-element lenses with anti-reflection coatings and optimized element arrangement, designers can reduce these unwanted effects and improve the clarity of the image.</li>
<li>Flexibility for Specialized Applications Multi-element lenses provide flexibility to tailor the design to specific tasks. For example: Telephoto lenses for long-range imaging. Wide-angle lenses for capturing more of a scene. Macro lenses for close-up imaging with minimal distortion. Anamorphic lenses for cinematic effects.</li>
</ol>
<p>Each type of lens may require multiple elements to achieve its particular optical objectives without compromising image quality.</p>
<ol start="11" type="1">
<li>Customization for Precision and Performance Advanced applications in scientific instruments, medical imaging, and industrial inspection require precise optical systems that may need a combination of elements to achieve the necessary accuracy. In such cases, a single lens cannot provide the high level of precision required, but a multi-element design can be carefully engineered for the exact performance needed. Summary</li>
</ol>
<p>Multi-element lenses are used because they allow optics designers to correct various aberrations, improve image quality, achieve wide fields of view, provide zoom functionality, control distortion, and optimize performance for specific applications. In contrast, a simple thin lens is limited in its ability to manage these factors, particularly when dealing with complex or high-performance optical systems.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>