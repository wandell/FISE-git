<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ip-spatial-metrics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ip-spatial-metrics_files/libs/clipboard/clipboard.min.js"></script>
<script src="ip-spatial-metrics_files/libs/quarto-html/quarto.js"></script>
<script src="ip-spatial-metrics_files/libs/quarto-html/popper.min.js"></script>
<script src="ip-spatial-metrics_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ip-spatial-metrics_files/libs/quarto-html/anchor.min.js"></script>
<link href="ip-spatial-metrics_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ip-spatial-metrics_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ip-spatial-metrics_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ip-spatial-metrics_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ip-spatial-metrics_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="spatial-metrics---prepared-by-chatgpt." class="level1">
<h1>Spatial metrics - prepared by ChatGPT.</h1>
<p>Prompt: There are many image quality metrics based on the human visual system. I am collecting those in a separate project. Here I am interested in image quality metrics that are designed for cameras and display devices, not necessarily connected to human vision. As an example, the ISO 12233 standard, which measures the MTF using a slanted bar target, is not deeply connected to human vision. The PSNR metric is not connected to human vision. I am looking for other references. I know of a standard called ‘Acutance’. Please create a list of such spatial image quality metrics.</p>
<p>https://chatgpt.com/share/6924dff1-96fc-8002-a2fb-e70afd2a886f</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 17%">
<col style="width: 16%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>Metric / Standard</th>
<th>Category</th>
<th>Purpose</th>
<th>Notes / Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>ISO 12233 Slanted-Edge MTF / SFR</strong></td>
<td>Resolution / Sharpness</td>
<td>Measures system MTF using the slanted-edge method (ESF → LSF → MTF)</td>
<td>Industry standard for camera/lens resolution testing.</td>
</tr>
<tr class="even">
<td><strong>MTF50 / MTF30 / MTF10</strong></td>
<td>Resolution / Sharpness</td>
<td>Single-number sharpness metrics derived from the MTF curve</td>
<td>Common in Imatest, DxO, DPReview.</td>
</tr>
<tr class="odd">
<td><strong>Acutance (ISO 20462/Imatest)</strong></td>
<td>Resolution / Sharpness</td>
<td>Integrates MTF with a weighting to yield overall sharpness</td>
<td>Weighting often not based on vision; used as a device metric.</td>
</tr>
<tr class="even">
<td><strong>Siemens Star Resolution</strong></td>
<td>Resolution</td>
<td>Radial resolution and asymmetry detection</td>
<td>Good for checking directional resolution limits.</td>
</tr>
<tr class="odd">
<td><strong>Line Pair Resolution (lp/mm)</strong></td>
<td>Resolution</td>
<td>Classical chart-based resolution measurement</td>
<td>Used in optical labs and film era; simple but widely used.</td>
</tr>
<tr class="even">
<td><strong>Random Texture MTF (ISO 19567-2)</strong></td>
<td>Texture Preservation</td>
<td>Measures texture rendering in presence of noise reduction/demosaicing</td>
<td>“Dead-leaves” chart; used heavily by DxO.</td>
</tr>
<tr class="odd">
<td><strong>Texture Frequency Loss (TFL)</strong></td>
<td>Texture Preservation</td>
<td>Quantifies suppression of fine texture</td>
<td>Derived from random texture MTF.</td>
</tr>
<tr class="even">
<td><strong>ISO 15739 Sharpness Metric</strong></td>
<td>Resolution / Texture</td>
<td>Sharpness in real scenes with noise present</td>
<td>Part of ISO imaging performance for DSC.</td>
</tr>
<tr class="odd">
<td><strong>Noise Power Spectrum (NPS)</strong></td>
<td>Noise</td>
<td>Frequency-dependent noise measurement</td>
<td>Standard for sensor evaluation in machine vision &amp; medical imaging.</td>
</tr>
<tr class="even">
<td><strong>Signal-to-Noise Ratio (SNR, SNR(dB))</strong></td>
<td>Noise</td>
<td>Basic engineering noise metric</td>
<td>Device-centric, not perceptual.</td>
</tr>
<tr class="odd">
<td><strong>Fixed-Pattern Noise (FPN)</strong></td>
<td>Sensor Noise</td>
<td>Measures spatially fixed noise contributions</td>
<td>Includes DSNU (dark signal) and PRNU (photo-response).</td>
</tr>
<tr class="even">
<td><strong>Photo-Response Nonuniformity (PRNU)</strong></td>
<td>Sensor Noise</td>
<td>Measures variance of pixel gain</td>
<td>Fundamental for CMOS/CCD characterization.</td>
</tr>
<tr class="odd">
<td><strong>Dark Signal Non-Uniformity (DSNU)</strong></td>
<td>Sensor Noise</td>
<td>Measures dark-current spatial variation</td>
<td>Temperature-dependent; sensor-level metric.</td>
</tr>
<tr class="even">
<td><strong>Pixel Aperture / Sensor MTF</strong></td>
<td>Sensor Resolution</td>
<td>Analytic or measured MTF of sensor pixel structure</td>
<td>Includes optical blur + charge diffusion.</td>
</tr>
<tr class="odd">
<td><strong>Charge Diffusion Width / Spot Spread</strong></td>
<td>Sensor Blur</td>
<td>Spatial blurring caused within the photodiode</td>
<td>Used in CMOS/CCD modeling and sensor datasheets.</td>
</tr>
<tr class="even">
<td><strong>Ringing / Overshoot / Undershoot Metrics</strong></td>
<td>Artifact Quantification</td>
<td>Measures artifacts from sharpening, deblurring, demosaicing</td>
<td>Extracted from the edge profile.</td>
</tr>
<tr class="odd">
<td><strong>Aliasing Energy (Spectral Folding)</strong></td>
<td>Artifacts</td>
<td>Measures energy above Nyquist that folds into lower frequencies</td>
<td>Used to evaluate sampling, CFA, &amp; lens interactions.</td>
</tr>
<tr class="even">
<td><strong>Demosaicing Artifact Metrics</strong></td>
<td>Artifacts</td>
<td>Quantifies false color or zippering</td>
<td>Often computed in Fourier domain or via local statistics.</td>
</tr>
<tr class="odd">
<td><strong>PSNR (Peak Signal-to-Noise Ratio)</strong></td>
<td>Fidelity</td>
<td>Pixelwise distortion measure</td>
<td>Device-centric; widely used in compression and pipeline tests.</td>
</tr>
<tr class="even">
<td><strong>MSE / RMSE</strong></td>
<td>Fidelity</td>
<td>Raw pixel error</td>
<td>No perceptual component.</td>
</tr>
<tr class="odd">
<td><strong>Linear Distortion Metrics (Gamma / Transfer Function)</strong></td>
<td>Linearity / Fidelity</td>
<td>Measures system response curve</td>
<td>Used in display and camera characterization.</td>
</tr>
<tr class="even">
<td><strong>ISO 9241-305 Display MTF</strong></td>
<td>Display Resolution</td>
<td>Resolution of display measured with a camera</td>
<td>Standard for spatial performance of displays.</td>
</tr>
<tr class="odd">
<td><strong>Pixel Structure / Subpixel MTF</strong></td>
<td>Display / Sensor Resolution</td>
<td>MTF from subpixel arrangement (OLED, LCD, µLED)</td>
<td>Important for VR/AR and microdisplays.</td>
</tr>
<tr class="even">
<td><strong>Display Uniformity Maps</strong></td>
<td>Display Uniformity</td>
<td>Spatial variation in luminance or contrast</td>
<td>Not HVS-based; purely physical uniformity metric.</td>
</tr>
<tr class="odd">
<td><strong>IEEE P1858 (CPIQ) Spatial Metrics (non-perceptual subset)</strong></td>
<td>Integrated System Metrics</td>
<td>Various device-centric spatial fidelity and texture metrics</td>
<td>Standardized test suite used by industry.</td>
</tr>
<tr class="even">
<td><strong>Veiling Glare Index / Flare</strong></td>
<td>Optical Artifact</td>
<td>Measures stray-light performance (e.g., contrast loss)</td>
<td>Classical photographic metric.</td>
</tr>
<tr class="odd">
<td><strong>RMS Granularity (Film)</strong></td>
<td>Texture / Noise</td>
<td>Noise texture metric from film imaging</td>
<td>Included for completeness in imaging history.</td>
</tr>
</tbody>
</table>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>